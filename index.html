<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Portfolio with 3D Eye</title>
<style>
  body, html {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background: #0a0a0a;
    font-family: Arial, sans-serif;
    color: #fff;
  }

  canvas {
    display: block;
  }

  /* Banner overlay */
  #banner {
    position: absolute;
    top: 50px;
    left: 50%;
    transform: translateX(-50%);
    width: 90%;
    max-width: 900px;
    background: hsla(0, 0%, 0%, 0);
    padding: 20px;
    border-radius: 15px;
    text-align: center;
    overflow-y: auto;
    max-height: 80%;
    z-index: 2;
  }

  #banner img {
    max-width: 100%;
    border-radius: 10px;
  }

  #banner a {
    color: #1e90ff;
    text-decoration: none;
  }

  #banner a:hover {
    text-decoration: underline;
  }

  h2, h3 {
    margin: 10px 0;
  }

  /* Container for the 3D eye */
  #containerEye {
    position: absolute;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    z-index: 1; /* behind banner */
  }
</style>
</head>
<body>

<canvas id="bgCanvas"></canvas>
<div id="containerEye"></div>




<script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
<script>
(() => { // IIFE to isolate scope
  // Starfield setup
  const canvas = document.getElementById('bgCanvas');
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 8000);
  camera.position.z = 800;

  const renderer = new THREE.WebGLRenderer({canvas: canvas, alpha:true});
  renderer.setSize(window.innerWidth, window.innerHeight);

  // Starfield geometry
  const starTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png');
  const particleCount = 2000;
  const geometry = new THREE.BufferGeometry();
  const positions = [];
  const colors = [];
  const sizes = [];

  for (let i = 0; i < particleCount; i++) {
    positions.push(
        (Math.random()-0.5)*2000, // ⬅️ reduced spread
        (Math.random()-0.5)*2000, 
        (Math.random()-0.5)*2000
      );
      const colorRand = Math.random();
      if(colorRand < 0.6) colors.push(1,1,1);
      else if(colorRand < 0.75) colors.push(1, 0.85, 0.5);
      else if(colorRand < 0.85) colors.push(1,0.5,0);
      else colors.push(0.5,0.7,1);
      sizes.push(Math.random()*5 + 1);
  }

  geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
  geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
  geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

  const material = new THREE.PointsMaterial({
      vertexColors: true,
      size: 4,
      map: starTexture,
      transparent: true,
      blending: THREE.AdditiveBlending,
      depthWrite: false
  });

  const stars = new THREE.Points(geometry, material);
  scene.add(stars);

  // Use unique variable names for mouse
  let starMouseX = 0, starMouseY = 0;
  document.addEventListener('mousemove', e => {
      starMouseX = (e.clientX - window.innerWidth/2)/50;
      starMouseY = (e.clientY - window.innerHeight/2)/50;
  });

  function animateStars() {
      requestAnimationFrame(animateStars);
      stars.rotation.y += 0.001 + starMouseX*0.001;
      stars.rotation.x += 0.001 + starMouseY*0.001;
      renderer.render(scene, camera);
  }
  animateStars();

  window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
  });
})();
</script>

<script type="module">
  import * as THREE from "https://cdn.skypack.dev/three@0.129.0/build/three.module.js";
  import { GLTFLoader } from "https://cdn.skypack.dev/three@0.129.0/examples/jsm/loaders/GLTFLoader.js";
  
  // Scene
  const sceneEye = new THREE.Scene();
  const cameraEye = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 2000);
  cameraEye.position.z = 600;
  
  const rendererEye = new THREE.WebGLRenderer({ alpha:true, antialias:true });
  rendererEye.setSize(window.innerWidth, window.innerHeight);
  document.getElementById("containerEye").appendChild(rendererEye.domElement);
  
  let pointerX = window.innerWidth/2, pointerY = window.innerHeight/2;
  let eyeObject;
  
  // Load eye model
  const loader = new GLTFLoader();
  loader.load(
    './eye_free_model_3d_by_oscar_creativo/scene.gltf',
    function(gltf){
      eyeObject = gltf.scene;
      eyeObject.scale.set(0.9, 0.9, 0.9); // smaller eye
      eyeObject.position.set(0, 0, 0);
      sceneEye.add(eyeObject);
      console.log("Eye model loaded:", eyeObject);
    },
    function(xhr){ console.log((xhr.loaded / xhr.total * 100) + '% loaded'); },
    function(err){ console.error(err); }
  );
  
  // Lights
  const topLight = new THREE.DirectionalLight(0xffffff, 1);
  topLight.position.set(500, 500, 500);
  sceneEye.add(topLight);
  
  const ambientLight = new THREE.AmbientLight(0x333333, 1);
  sceneEye.add(ambientLight);
  
  // Animate
  function animateEye(){
    requestAnimationFrame(animateEye);
  
    if(eyeObject){
      // Eye rotates based on pointer position (mouse or touch)
      eyeObject.rotation.y = -3 + pointerX / window.innerWidth * 3;
      eyeObject.rotation.x = -1.2 + pointerY * 2.5 / window.innerHeight;
    }
  
    rendererEye.render(sceneEye, cameraEye);
  }
  animateEye();
  
  // 🖱️ Desktop mouse tracking
  document.addEventListener("mousemove", (e)=>{
    pointerX = e.clientX;
    pointerY = e.clientY;
  });
  
  // 📱 Mobile touch tracking
  document.addEventListener("touchmove", (e)=>{
    const touch = e.touches[0];
    pointerX = touch.clientX;
    pointerY = touch.clientY;
  }, { passive: true });
  
  // Resize
  window.addEventListener('resize', ()=>{
    cameraEye.aspect = window.innerWidth/window.innerHeight;
    cameraEye.updateProjectionMatrix();
    rendererEye.setSize(window.innerWidth, window.innerHeight);
  });
</script>


</body>
</html>
